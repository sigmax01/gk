---
title: 数据库:存储与索引
comments: false
---

## 存储介质

在DBMS中, 存在两个非常重要的问题: 1. 如何高效地组织非常大量的数据; 2. 如何高效地访问数据, 即最小化输入/输出操作. 

它对于存储介质的要求有: 数据库需要保存到持久存储中, 例如硬盘和固态硬盘. 尽管内存的价格逐渐降低, 但是新兴应用程序对海量存储能力的需求日益增长, 远远超过了内存的容量. 硬盘和内存的比较可见[图](https://img.ricolxwz.io/0e33d17552e6214d7c0fc659d3af8586.png).

对于DBMS来说, 主要关注的是硬盘, 因为大多数的操作都是在磁盘和内存之间进行的读写操作, 这意味着IO操作的性能对系统的整体性能影响很大. 相比之下, 与IO相关的限制更为显著, 因此数据库系统的性能优化更倾向于减少IO操作而不是提高CPU的计算效率.

### 数据块

数据块是磁盘和内存之间传输的基本单位, 它的大小是由操作系统在初始化的时候定义的, 通常会跨越多个扇区(sector). 例如, 块的大小可以是4096字节(4K), 8K等. 关于数据块, 扇区, 磁道, 柱面在磁盘中的具象化表示请见[图](https://img.ricolxwz.io/ba5649d25f3eaf7d70712affb662f69e.png).

在磁盘上是没有逻辑记录的概念的, 它只能识别块, 并不关系这些块中包含的是怎样的数据, 当数据从磁盘上的一个块被读取并加载到内存中的缓冲区的时候, DBMS会对块中的原始数据进行解析, 将其划分为有意义的结构化数据单元, 即逻辑记录, 就是"元祖", 表中的一行行记录.

#### 阻塞因子

阻塞因子, blocking factor, 记录的是块大小和记录大小之间的关系, 公式为b=块大小/记录大小. 它表示的是一个块能够容纳多少个记录. 当b<1的时候, 块大小小于记录大小, 这意味着一个记录不能完整地放入一个块中, 这会导致"记录跨块", record spanning, 即需要多个块来存储一个记录. 由于记录跨块对性能的影响十分明显, 防止这种现象的发生对于DBMS的高效存储和检索非常重要.

### IO时间

对于磁盘来说, 其读取/写入时间, 即IO时间主要由3部分组成:

- 寻道时间: 磁头移动到正确的磁道的时间
- 旋转延迟: 当磁头定位到正确的磁道后, 还需要等待磁盘旋转到正确的位置的时间, 取决于磁盘的旋转速度
- 传输时间: 当磁头到达正确的位置后, 实际读取或写入过程开始, 数据从磁盘读取或写入的时间

### 缓存管理

注意, 整个数据库是无法放到内存里面的, 但是内存能够提供一个数据块的缓冲区. 由于磁盘IO是极其耗费时间的, 所以我们会尽量保证数据库放在内存中以便后续快速读取/写入. 

为了提高效率, 需要设计策略来"预测"应用程序可能会请求哪些块, 以便在请求的时候这些块已经存在于缓冲区中, 从而减少IO操作的频率. 缓存管理器负责管理这些策略. 如当缓冲区满, 程序需要一个数据块的时候, 缓冲区中的哪一个数据块应该被替换掉, 即, 最好的替换算法是什么? 

主要有两种算法: LRU(Least Recently Used)和MRU(Most Recently Used).

???+ example "例子"

    假设现在有两个关系: Borrower和Customer, 假设每个关系都存储在单独的文件中. 它们唯一共同的属性是customer_name. 现在, 要执行一个自然连接的操作, 对于每一个Borrwer都要遍历一遍所有的Customer记录, 查找记录的customer_name是否一致, 然后加入到新表中.

    假设缓存区有的容量为三个数据块, 而Customer关系有4条记录, c1, c2, c3, c4, 每个记录刚好占用一个块. 那么哪种缓存策略更加合适?

    - LRU: 最近最少使用, 这种策略替换最久没有被使用的块. 按照这个例子, 先存储c1, c2, c3, 在读取c4的时候, 最久未使用的是c1, 因此将c1替换为c4. 接着对于下一个Borrower, 读取c1, 所以又要将c2替换出去, 到此为止, 出现了2次页面置换, page faults
    - MRU: 最近最常使用, 这种策略替换最近刚使用的块. 在读取c4的时候, 最近使用的块是c3, 因此将c3替换为c4. 接着操作读取c1, 不需要进行替换操作, 所以到此为止, 出现了1次页面置换

    因此, 在这个特定的操作中, 使用MRU的策略会更好, 因为它比LRU导致的页面置换更少.

### 平均故障时间

