---
title: 数据库:存储与索引
comments: false
---

## 存储介质

在DBMS中, 存在两个非常重要的问题: 1. 如何高效地组织非常大量的数据; 2. 如何高效地访问数据, 即最小化输入/输出操作. 

它对于存储介质的要求有: 数据库需要保存到持久存储中, 例如硬盘和固态硬盘. 尽管内存的价格逐渐降低, 但是新兴应用程序对海量存储能力的需求日益增长, 远远超过了内存的容量. 硬盘和内存的比较可见[图](https://img.ricolxwz.io/0e33d17552e6214d7c0fc659d3af8586.png).

对于DBMS来说, 主要关注的是硬盘, 因为大多数的操作都是在磁盘和内存之间进行的读写操作, 这意味着IO操作的性能对系统的整体性能影响很大. 相比之下, 与IO相关的限制更为显著, 因此数据库系统的性能优化更倾向于减少IO操作而不是提高CPU的计算效率.

### 数据块

数据块是磁盘和内存之间传输的基本单位, 它的大小是由操作系统在初始化的时候定义的, 通常会跨越多个扇区(sector). 例如, 块的大小可以是4096字节(4K), 8K等. 关于数据块, 扇区, 磁道, 柱面在磁盘中的具象化表示请见[图](https://img.ricolxwz.io/ba5649d25f3eaf7d70712affb662f69e.png).

在磁盘上是没有逻辑记录的概念的, 它只能识别块, 并不关系这些块中包含的是怎样的数据, 当数据从磁盘上的一个块被读取并加载到内存中的缓冲区的时候, DBMS会对块中的原始数据进行解析, 将其划分为有意义的结构化数据单元, 即逻辑记录, 就是"元祖", 表中的一行行记录.

#### 阻塞因子

阻塞因子, blocking factor, 记录的是块大小和记录大小之间的关系, 公式为b=块大小/记录大小. 它表示的是一个块能够容纳多少个记录. 当b<1的时候, 块大小小于记录大小, 这意味着一个记录不能完整地放入一个块中, 这会导致"记录跨块", record spanning, 即需要多个块来存储一个记录. 由于记录跨块对性能的影响十分明显, 防止这种现象的发生对于DBMS的高效存储和检索非常重要.

### IO时间

对于磁盘来说, 其读取/写入时间, 即IO时间主要由3部分组成:

- 寻道时间: 磁头移动到正确的磁道的时间
- 旋转延迟: 当磁头定位到正确的磁道后, 还需要等待磁盘旋转到正确的位置的时间, 取决于磁盘的旋转速度
- 传输时间: 当磁头到达正确的位置后, 实际读取或写入过程开始, 数据从磁盘读取或写入的时间

### 缓存管理

注意, 整个数据库是无法放到内存里面的, 但是内存能够提供一个数据块的缓冲区. 由于磁盘IO是极其耗费时间的, 所以我们会尽量保证数据库放在内存中以便后续快速读取/写入. 

为了提高效率, 需要设计策略来"预测"应用程序可能会请求哪些块, 以便在请求的时候这些块已经存在于缓冲区中, 从而减少IO操作的频率. 缓存管理器负责管理这些策略. 如当缓冲区满, 程序需要一个数据块的时候, 缓冲区中的哪一个数据块应该被替换掉, 即, 最好的替换算法是什么? 

主要有两种算法: LRU(Least Recently Used)和MRU(Most Recently Used).

???+ example "例子"

    假设现在有两个关系: Borrower和Customer, 假设每个关系都存储在单独的文件中. 它们唯一共同的属性是customer_name. 现在, 要执行一个自然连接的操作, 对于每一个Borrwer都要遍历一遍所有的Customer记录, 查找记录的customer_name是否一致, 然后加入到新表中.

    假设缓存区有的容量为三个数据块, 而Customer关系有4条记录, c1, c2, c3, c4, 每个记录刚好占用一个块. 那么哪种缓存策略更加合适?

    - LRU: 最近最少使用, 这种策略替换最久没有被使用的块. 按照这个例子, 先存储c1, c2, c3, 在读取c4的时候, 最久未使用的是c1, 因此将c1替换为c4. 接着对于下一个Borrower, 读取c1, 所以又要将c2替换出去, 到此为止, 出现了2次页面置换, page faults
    - MRU: 最近最常使用, 这种策略替换最近刚使用的块. 在读取c4的时候, 最近使用的块是c3, 因此将c3替换为c4. 接着操作读取c1, 不需要进行替换操作, 所以到此为止, 出现了1次页面置换

    因此, 在这个特定的操作中, 使用MRU的策略会更好, 因为它比LRU导致的页面置换更少.

### 平均故障时间

平均故障时间, Mean Time To Failure, MTTF是一个统计值, 用来描述硬盘在出现故障前的平均运行时间. 根据硬盘型号的不同, MTTF通常在一百万小时, 约114年到250万小时, 约285年之间. 硬盘随时会发生故障, 因此需要定时备份和使用RAID配置来防止数据丢失.

???+ example "例子"

    在实际中, 当有大量硬盘的时候, MTTF可以帮助估算故障的频率. 例如, 如果MTTF为一百万小时且有一万个硬盘, 那么每小时可能会有一个硬盘发生故障, 如果硬盘数量减少到1000个, 那么在相同MTTF下, 每1000小时可能会有一个硬盘发生故障.

### 数据传输的关键优化方法

物理传输可以通过一些方法进行优化:

- 块传输: 通过以固定大小的块为单位进行数据传输, 从而减少单个数据传输的开销
- 基于柱面访问: 这种方法减少了磁头移动的距离, 通过优先访问同一个柱面上的数据, 可以减少磁头在磁盘表面移动的次数
- 多磁盘: 使用多个磁盘并行操作来增加数据的吞吐量
- 磁盘调度: 通过优化磁盘的读写请求顺序来减少磁头移动, 常见的调度算法有先来先服务, FCFS; 最短寻道时间优先, SSTF等
- 预取/双缓冲: 在需要时提前读取数据到内存或者使用双缓冲技术以减少等待时间, 确保磁盘在一个任务完成时可以立即开始下一个任务

### 廉价磁盘冗余阵列

廉价磁盘冗余阵列, Redundant Array of Inexpensive Disks, RAID, 是一种磁盘组织技术, 将大量磁盘抽象成一个逻辑盘. 它的优点包括高容量, 高速和高可靠性. 不同的RAID方案通过[磁盘条带化(striping)](https://blog.csdn.net/jlds123/article/details/11813313)和奇偶检验位的组合来以较低的成本实现冗余, [不同的RAID级别](https://blog.csdn.net/tototuzuoquan/article/details/108914078)在成本, 性能和可靠性方面具有不同的特点.

### 数据的组织和存储

在DBMS中, 表被存储为记录的集合, 并称之为一个文件. 一个文件由一个或多个页面组成, 每个页面存储的记录都来自一个表, 页面是内存中用于管理数据的最小单元, 缓存管理器负责管理这些页面. 磁盘空间管理器负责将页面请求转换为磁盘块请求, 每个页面可能由一个或多个磁盘块组成.

???+ info "信息"

    在接下来的讲解中, 默认情况下, 一个页面等于一个磁盘块, 除非另有说明.

???+ example "例子"

    假设我们在一张关系中由2000000条记录, 每个记录的大小是200bytes(如[图](https://img.ricolxwz.io/bfe6c446313ac27bd671dc451cf181e4.png)). 每页的大小为4k bytes, 其中250字节用于页头和记录指针数组, 所以实际可用于存储记录的字节数为3846字节. 每条记录为200字节, 所以每页可以容纳3846/200=19条记录(取整, 不能存放部分记录, 如[图](https://img.ricolxwz.io/608fa18ec145304fce55fc0ad2d53bbb.png)所示, 剩余46bytes). 那么, 所需要的页数为2000000/19=105264页(向上取整, 因为需要完整存储所有记录, 最后一个页面包含3个记录, 如[图](https://img.ricolxwz.io/7517093961f7a252d10d2321aa4d002c.png)所示). 

    需要的大小是2000000\*200=400000000bytes. 而实际给出的大小是105264\*4096=431161344bytes. 所以有(431161344-400000000)/400000000=7.79%的overhead.

#### 填充因子

填充因子, occupancy. 我们用一个例子来解释. 假设每个数据页的大小为4KB, 4096字节. 每个页有250字节用于页头和记录指针数组, 这些空间用于存储元数据, 所以实际可用的空间为3846字节. 假设填充因子设置为80%, 这意味着我们希望每个页的80%空间用于存储数据, 剩下的20%空间预留为空闲, 用于将来插入新数据时候的扩展, 80%的填充因子意味着在3846字节中, 我们会使用3846\*0.8=3076字节来存储数据, 剩下的3846\*0.2=770字节被保留下来.

设置occupancy小于100%能够为未来地插入和更新预留了足够地空间, 有助于提高写操作的效率, 并降低索引树的高度增长和系统碎片化. 因此, 设定较低的填充因子是一种权衡性能和空间利用率的做法, 以提高数据库整体的操作效率.

???+ example "例子"

    在上面的例子中, 假设填充因子为75%. 那么原先每页能存19条记录, 现在每页只能存19\*75%=14.25, 14条记录. 那么现在总共有2000000/14=142858条记录, 那么总共有142858\*4096=585146368bytes. 根据之前计算overhead的公式, 它有46.28%的overhead.

### 文件组织 {#file-organisation}

对于数据库中的一张表或者一个文件来说, 其记录可以采用不同的索引方式存储在磁盘上, 这些方式会显著影响数据的检索和更新效率.

- 无序文件: 表中的记录没有特定的顺序存储, 数据插入的时候会存放在任何可用的空间中. 适合批量读取或需要描述整个表的情况
- 排序文件: 表中的记录按照某个字段排序存储. 这样可以加快基于该字段的检索(如二分查找), 但是插入和删除操作较为耗时, 因为需要保持排序状态
- 索引: 为表中的一个或者多个字段创建索引, 以便加快基于这些字段的搜索. 索引类似于一本书的目录, 通过索引可以快速定位到特定记录. 更新操作相对高效, 因为不需要重新排列整个表的数据

这和我们下一小节要将的内容有关.

## 访问路径

访问路径, 即DBMS如何检索记录的方式, 在[文件组织](#file-organisation)中, 我们提到, 对于文件的记录有不同的索引方式, 不同的索引方式其访问方法也不同.

- 线性扫描: 对于无序文件来说, 从头到尾注意扫描所有记录, 直到找到目标记录
- 二分查找: 对于排序文件来说, 使用二分查找可以更快速地找到特定记录 
- 索引扫描: 通过索引结构(B树或者哈希表)快速定位到目标记录

???+ tip "Tip"

    物理数据独立性: 在执行SQL语句地时候, 选择地访问路径不会影响语句的语义, 即查询的结果不会改变. 例如对于`SELECT * FROM Student WHERE sid = 5309650`这个查询, 无论使用线性扫描, 二分查找, 还是索引扫描, 结果都是相同的.

    尽管访问路径的选择不影响查询的语义, 但是它对查询的执行时间有很大影响. 不同的访问路径可能导致查询的执行效率差异极大, 进而影响数据库的性能. 因此, 合理选择访问路径对于提高查询速度非常重要.

### 线性扫描
